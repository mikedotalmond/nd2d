package net.nicoptere.delaunay{	import de.nulldesign.nd2d.geom.Vertex;	import flash.geom.Point;	import flash.geom.Vector3D;	import net.nicoptere.delaunay.DelaunayTriangle;	import net.nicoptere.delaunay.DelaunayEdge;			//Credit to Paul Bourke (pbourke@swin.edu.au) for the original Fortran 77 Program :))	//Converted to a standalone C# 2.0 library by Morten Nielsen (www.iter.dk)	//Check out: http://astronomy.swin.edu.au/~pbourke/terrain/triangulate/	//You can use this code however you like providing the above credits remain intact	/**	 * @author nicoptere	 * http://en.nicoptere.net/	 */		/**	 * @author Mike Almond - https://github.com/mikedotalmond 	 * modifications for use with nd2d	*/	 	public final class Delaunay		{				/**		 * performs a Delaunay triangulation on a  set of points 		 * @param points the original Vector of points		 * @return a Vector.<DelaunAyTriangle> of delaunay triangles		 * 		 */		public static function Triangulate( points:Vector.<Vector3D> ):Vector.<DelaunayTriangle> {						var i	:int;			var j	:int;			const nv:int = points.length;						if (nv < 3) return null;						const trimax:uint = nv << 2;									// Find the maximum and minimum vertex bounds.			// This is to allow calculation of the bounding supertriangle			var xmin:Number = points[0].x;			var ymin:Number = points[0].y;			var xmax:Number = xmin;			var ymax:Number = ymin;						const vertices	:Vector.<Vertex> = new Vector.<Vertex>(nv, true);			var vertex		:Vertex;						for ( i = 0; i < nv; i++) {								vertex			 = new Vertex(points[i].x, points[i].y, 0);				vertex.bufferIdx = i;				if (vertex.x < xmin) xmin = vertex.x;				if (vertex.x > xmax) xmax = vertex.x;				if (vertex.y < ymin) ymin = vertex.y;				if (vertex.y > ymax) ymax = vertex.y;				vertices[i] = vertex;			}						const dx	:Number = xmax - xmin;			const dy	:Number = ymax - ymin;			const dmax	:Number = (dx > dy) ? dx : dy;			const xmid	:Number = (xmax + xmin) * 0.5;			const ymid	:Number = (ymax + ymin) * 0.5;			// Set up the supertriangle			// This is a triangle which encompasses all the sample points.			// The supertriangle coordinates are added to the end of the			// vertex list. The supertriangle is the first triangle in			// the triangle list.			vertices.fixed = false;						vertex = new Vertex((xmid - 2 * dmax), (ymid - dmax), 0); 			vertex.bufferIdx = nv + 1;			vertices.push(vertex);						vertex = new Vertex(xmid, (ymid + 2 * dmax), 0);						vertex.bufferIdx = nv + 2;			vertices.push(vertex);						vertex = new Vertex((xmid + 2 * dmax), (ymid - dmax), 0);			vertex.bufferIdx = nv + 3;			vertices.push(vertex);						vertices.fixed = true;			var triangles:Vector.<DelaunayTriangle> = new Vector.<DelaunayTriangle>();			triangles.push( new DelaunayTriangle(vertices[nv], vertices[nv + 1], vertices[nv + 2])); //SuperTriangle placed at index 0						var DelaunayEdges:Vector.<DelaunayEdge>;			// Include each point one at a time into the existing mesh			for ( i = 0; i < nv; i++) {				DelaunayEdges = new Vector.<DelaunayEdge>();				// Set up the DelaunayEdge buffer.				// If the point (vertex(i).x,vertex(i).y) lies inside the circumcircle then the				// three DelaunayEdges of that triangle are added to the DelaunayEdge buffer and the triangle is removed from list.				for ( j = 0; j < triangles.length; j++ ) {					if (InCircle(vertices[i], triangles[j].p1, triangles[j].p2, triangles[j].p3)){						DelaunayEdges.push(new DelaunayEdge(triangles[j].p1, triangles[j].p2));						DelaunayEdges.push(new DelaunayEdge(triangles[j].p2, triangles[j].p3));						DelaunayEdges.push(new DelaunayEdge(triangles[j].p3, triangles[j].p1));						triangles.splice(j, 1);						j--;					}				}								if ( i >= nv) continue; //In case we the last duplicate point we removed was the last in the array								// Remove duplicate DelaunayEdges				// Note: if all triangles are specified anticlockwise then all				// interior DelaunayEdges are opposite pointing in direction.				for ( j = DelaunayEdges.length - 2; j >= 0; j--) {					for (var k:int = DelaunayEdges.length - 1; k >= j + 1; k--) {						if ( DelaunayEdges[ j ].equals( DelaunayEdges[ k ] ) ) {							DelaunayEdges.splice( k, 1 );							DelaunayEdges.splice( j, 1 );							k--;							continue;						}					}				}				// Form new triangles for the current point				// Skipping over any tagged DelaunayEdges.				// All DelaunayEdges are arranged in clockwise order.				for ( j = 0; j < DelaunayEdges.length; j++) {					if (triangles.length >= trimax ) {						trace("Exceeded maximum DelaunayEdges");					}					triangles.push( new DelaunayTriangle( DelaunayEdges[ j ].p1, DelaunayEdges[ j ].p2, vertices[ i ] ));				}				DelaunayEdges = null;			}						// Remove triangles with supertriangle vertices			// These are triangles which have a vertex number greater than nv			for ( i = triangles.length - 1; i >= 0; i--) {				if ( triangles[i].p1.bufferIdx >= nv || triangles[i].p2.bufferIdx >= nv || triangles[i].p3.bufferIdx >= nv) {					triangles.splice(i, 1);				}			}						triangles.fixed = true;			return triangles;		}		/// <summary>		/// Returns true if the point (p) lies inside the circumcircle made up by points (p1,p2,p3)		/// </summary>		/// <remarks>		/// NOTE: A point on the DelaunayEdge is inside the circumcircle		/// </remarks>		/// <param name="p">Point to check</param>		/// <param name="p1">First point on circle</param>		/// <param name="p2">Second point on circle</param>		/// <param name="p3">Third point on circle</param>		/// <returns>true if p is inside circle</returns>		static private const Epsilon:Number = Number.MIN_VALUE;		private static function InCircle( p:Vertex, p1:Vertex, p2:Vertex, p3:Vertex ):Boolean {						//Return TRUE if the point (xp,yp) lies inside the circumcircle			//made up by points (x1,y1) (x2,y2) (x3,y3)			//NOTE: A point on the DelaunayEdge is inside the circumcircle			if ( Math.abs( p1.y - p2.y ) < Epsilon && Math.abs( p2.y - p3.y) < Epsilon) {				//INCIRCUM - F - Points are coincident !!				return false;			}						var m1:Number;			var m2:Number;			var mx1:Number;			var mx2:Number;			var my1:Number;			var my2:Number;			var xc:Number;			var yc:Number;			if ( Math.abs(p2.y - p1.y) < Epsilon) {				m2 	= -(p3.x - p2.x) / (p3.y - p2.y);				mx2 = (p2.x + p3.x) * 0.5;				my2 = (p2.y + p3.y) * 0.5;				//Calculate CircumCircle center (xc,yc)								xc = (p2.x + p1.x) * 0.5;				yc = m2 * (xc - mx2) + my2;			} else if ( Math.abs(p3.y - p2.y) < Epsilon) {				m1 = -(p2.x - p1.x) / (p2.y - p1.y);				mx1 = (p1.x + p2.x) * 0.5;				my1 = (p1.y + p2.y) * 0.5;				//Calculate CircumCircle center (xc,yc)				xc = (p3.x + p2.x) * 0.5;				yc = m1 * (xc - mx1) + my1;							} else {								m1 = -(p2.x - p1.x) / (p2.y - p1.y);				m2 = -(p3.x - p2.x) / (p3.y - p2.y);				mx1 = (p1.x + p2.x) * 0.5;				mx2 = (p2.x + p3.x) * 0.5;				my1 = (p1.y + p2.y) * 0.5;				my2 = (p2.y + p3.y) * 0.5;								//Calculate CircumCircle center (xc,yc)				xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);				yc = m1 * (xc - mx1) + my1;			}						var dx		:Number = p2.x - xc;			var dy		:Number = p2.y - yc;			const rsqr	:Number = dx * dx + dy * dy;						dx = p.x - xc;			dy = p.y - yc;						return ( (dx * dx + dy * dy) <= rsqr );		}	}}